# execution/spec_builder.py
# Dynamic step implementation generator for Gauge

import logging
import os
import sys
import argparse
from pathlib import Path

# Add project root to path
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
import config


logger = logging.getLogger(__name__)


def build_step_impl_header() -> str:
    """
    Returns the full step implementation file as a string.
    This file will be written to step_impl/step_impl.py
    """

    return r'''# step_impl/step_impl.py
# Auto-generated by AI-Driven Gauge Tester

import os
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait, Select
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException
from selenium.webdriver.common.action_chains import ActionChains

from getgauge.python import step, before_suite, after_suite, after_scenario, data_store

from execution.webdriver_initializer import get_driver, quit_driver
import config


WAIT_TIMEOUT = getattr(config, "IMPLICIT_WAIT", 10)


@before_suite
def before_suite_hook():
    get_driver()


@after_suite
def after_suite_hook():
    quit_driver()


@after_scenario
def after_scenario_hook():
    """Take screenshot only if scenario failed."""
    if not getattr(config, "SCREENSHOT_ON_FAILURE", False):
        return

    try:
        status = data_store.scenario.get("executionStatus")
        if status and status.lower() == "failed":
            driver = get_driver()
            os.makedirs(config.REPORTS_DIR, exist_ok=True)
            name = data_store.scenario.get("scenarioName", "failed_scenario")
            name = name.replace(" ", "_")[:50]
            path = os.path.join(config.REPORTS_DIR, f"{name}.png")
            driver.save_screenshot(path)
    except Exception as e:
        print(f"Screenshot capture failed: {e}")


@step('Navigate to "<url>"')
def navigate_to(url):
    driver = get_driver()
    driver.get(url)


@step('Click on "<target>"')
def click_on(target):
    driver = get_driver()
    el = _find(driver, target)
    el.click()


@step('Type "<value>" in "<target>"')
def type_in(value, target):
    driver = get_driver()
    el = _find(driver, target)
    el.clear()
    el.send_keys(value)


@step('Verify "<target>" contains "<value>"')
def verify_contains(target, value):
    driver = get_driver()
    el = _find(driver, target)
    actual = el.text.strip()
    assert value.lower() in actual.lower(), \
        f"Expected '{value}', but got '{actual}'"


def _selector(target: str):
    if (
        target.startswith("#")
        or target.startswith(".")
        or target.startswith("[")
        or (" " not in target and (">" in target or ":" in target))
    ):
        return (By.CSS_SELECTOR, target)

    if target.startswith("//") or target.startswith("(//"):
        return (By.XPATH, target)

    return (By.ID, target)


def _find(driver, target: str, timeout: int = WAIT_TIMEOUT):
    wait = WebDriverWait(driver, timeout)

    strategies = [
        (By.CSS_SELECTOR, target),
        (By.ID, target),
        (By.NAME, target),
        (By.XPATH, f"//*[contains(text(), '{target}')]"),
        (By.XPATH, f"//*[@aria-label='{target}']"),
    ]

    for by, value in strategies:
        try:
            return wait.until(
                EC.visibility_of_element_located((by, value))
            )
        except (TimeoutException, NoSuchElementException):
            continue

    raise NoSuchElementException(f"Element not found: '{target}'")
'''


def write_step_impl(path: str = None):
    """Write generated step_impl.py to disk."""
    path = path or os.path.join(config.BASE_DIR, "step_impl", "step_impl.py")

    os.makedirs(os.path.dirname(path), exist_ok=True)

    with open(path, "w", encoding="utf-8") as f:
        f.write(build_step_impl_header())

    logger.info(f"✓ step_impl.py generated at: {path}")
    print(f"✓ step_impl.py generated at: {path}")


# ─────────────────────────────────────────────────────────────
# Main Entry Point
# ─────────────────────────────────────────────────────────────

def main():
    parser = argparse.ArgumentParser(
        description="Generate Gauge step implementation file dynamically."
    )

    parser.add_argument(
        "--output",
        type=str,
        help="Optional custom output path for step_impl.py"
    )

    args = parser.parse_args()

    write_step_impl(args.output)


if __name__ == "__main__":
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s | %(levelname)s | %(message)s"
    )

    main()